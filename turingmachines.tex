\documentclass[main.tex]{subfiles}
\begin{document}

\chapter{Turingmachines en beslisbaarheid}
\label{cha:turingmachines-en-beslisbaarheid}


\begin{de}
  Een \term{Turingmachine} is een $7$-tal $(Q,\Sigma,\Gamma, \delta, q_{s}, q_{a}, q_{r})$:
  \begin{itemize}
  \item $Q$ is een eindige verzameling toestanden
  \item $\Sigma$ is een eindig invoeralfabet dat $\#$ niet bevat.
  \item $\Gamma$ is een eindig bandalfabet dat $\#$ bevat, alsook $\Sigma$.
  \item $q_{s}$ is de starttoestand.
  \item $q_{a}$ is de aanvaardende toestand.
  \item $q_{r}$ is de verwerpende toestand.
  \item $\delta$ is de totale overgangsfunctie.
  \[ \delta:\ Q \times \Gamma \rightarrow Q \times \Gamma \times \{L,R,S\} \]
  \end{itemize}
  Een Turingmachine beschikt over een strook geheugen die aan twee kanten onbegrensd is.
  Deze strook is ingedeeld in vakjes die precies \'e\'en symbool bevatten.
  De Turingmachine beschikt bovendien over een lees- en schrijfeenheid die zich over een vakje bevindt dat de machine bijgevolg kan lezen en waarnaar de machine kan schrijven.
  De Turingmachine bevindt zich op elk moment in precies \'e\'en toestand.
\end{de}

\begin{de}
  De \term{werking van een Turingmachine} definieren we aan de hand van een Turingmachine $M = (Q,\Sigma,\Gamma, \delta, q_{s}, q_{a}, q_{r})$ en een invoerstring $s$.
  \begin{itemize}
  \item \textbf{Initialisatie}\\
    De geheugenstrook wordt eerst ge\"initialiseerd zodat ze enkel het symbool $\#$ bevat in op elk vakje.
    Vervolgens wordt vanaf een willekeurig vakje opeenvolgend de invoerstring in de vakjes op de band gezet.
    De lees- en schrijfeenheid wordt op het vakje gezet waar de string begint.
    De machine bevindt zich aan het begin in de begintoestand $q_{s}$.
  \item \textbf{Uitvoering}\\
    De Turingmachine $M$ voert achtereenvolgens de volgende stappen uit.
    \begin{itemize}
    \item De machine leest het symbool dat onder de lees- en schrijfeenheid staat.
    \item Op basis van de staat $q$ waarin de machine zich bevindt en het symbool $a$ onder de eenheid beslist de machine wat hij zal doen aan de hand van de overgangsfunctie.
      \[ \delta(q,a) = (q',a',r) \]
      De machine zal het symbool $a'$ schrijven, naar staat $q'$ overgaan en zicht in de richting $r$ verplaatsen.
    \end{itemize}
  \item \textbf{Beslissing}\\
    Zodra de machine zich ofwel in $q_{a}$ ofwel in $q_{r}$ bevindt stopt hij.
    Als de machine zich op het einde in $q_{a}$ bevindt zeggen we dat $M$ de string $s$ aanvaardt.
    Als de machine zich op het einde in $q_{r}$ bevindt zeggen we dat $M$ de string $s$ verwerpt.
    Merk op dat het ook kan voorvallen dat de machine bij een gegeven string $s$ niet ophoudt met werken.
  \end{itemize}
\end{de}

\begin{de}
  Elke turingmachine $M$ bepaalt een verdeling van $\Sigma^{*}$ in drie stukken:
  \begin{itemize}
  \item De strings die door $M$ worden geaccepteerd: $L_{M}$.
  \item De strings waarvoor $M$ in een oneindige lus belandt: $\infty_{M}$.
  \item De strings die door $M$ worden verworpen.
  \end{itemize}
\end{de}

\begin{de}
  Een turingmachine $M$ \term{herkent} $L_{M}$.
\end{de}

\begin{de}
  Een taal $L$ is \term{Turing-herkenbaar} als er een Turingmachine $M$ bestaat die $L$ herkent.
\end{de}

\begin{de}
  Een turingmachine $M$ \term{beslist} een taal $L$ als $M$ $L$ herkent en $\infty_{M}$ leeg is.
\end{de}

\begin{de}
  Een taal $L$ is \term{Turing-beslisbaar} als er een Turingmachine $M$ bestaat die $L$ beslist.
\end{de}

\begin{de}
  Een taal $L$ is \term{co-herkenbaar} als $\bar{L}$ herkenbaar is.
\end{de}

\begin{de}
  Een taal $L$ is \term{co-beslisbaar} als $\bar{L}$ beslisbaar is.
\end{de}

\begin{st}
  \label{st:herk-plus-coherk-is-besl}
  Als een taal $L$ zowel herkenbaar als co-herkenbaar is, dan is $L$ beslisbaar (en co-beslisbaar).
  \begin{proof}
    Kies een willekeurige herkenbare en co-herkenbare taal $L$.
    Er bestaat dan een Turingmachine $m$ die $L$ herkent en een Turingmachine $m'$ die $\bar{L}$ herkent.
    Construeer vanuit $m$ en $m'$ nu een machine $M$ die $L$ beslist.
    $M$ bestaat erin $m$ en $m'$ simultaan te laten lopen op de invoerstring $s$
    Zodra $m$ $s$ aanvaardt, aanvaardt $m$ $s$ en zodra $m'$ $s$ aanvaardt, verwerpt $m$ $s$.
    Voor elke mogelijke invoerstring stopt minstens \'enen van de machines $m$ en $m'$.
    $M$ zal dus altijd stoppen.
  \end{proof}
\end{st}

\begin{st}
  Er bestaat een taal die niet herkenbaar is.
  \begin{proof}
    Het aantal Turingmachines is aftelbaar oneindig (, maar enkel op isomorfisme na).
    Elke (equivalentieklasse van) Turingmachine(s) herkent bovendien precies \'e\'en taal.
    Het aantal talen over een gegeven alfabet is overaftelbaar oneindig.\footnote{Zie stelling \ref{st:overaftelbaar-veel-talen}.}
    Er bestaat dus minstens \'e\'en taal waarvoor er geen Turingmachine bestaat die die taal herkent.
    Die taal is niet herkenbaar.
    Sterker nog: ``De meeste\footnote{``De meeste'' heeft een heel specifieke wiskundige betekenis.} talen zijn niet herkenbaar.''
  \end{proof}
\end{st}

\begin{de}
  Zij $M = (Q,\Sigma,\Gamma, \delta, q_{s}, q_{a}, q_{r})$ een Turingmachine die zich in een staat $q$ bevindt tijdens de uitvoering. 
  Zij $\alpha$ de niet-$\#$ symbolen links van de schrijfeenheid en $\beta$ de niet-$\#$ symbolen onder en rechts van de schrijfeenheid.
  We noteren dan deze \term{configuratie} van $M$ als volgt.
  \[ \alpha q \beta \]
\end{de}

\begin{opm}
  Merk op dat er links en rechts van de schrijfeenheid altijd een aantal vakjes bestaan waarna alle vakjes een $\#$-symbool bevatten.
  Dit betekent echter niet dat alle symbolen tot dat niet-$\#$-symbolen zijn.
  In de bovenstaande definitie bedoelen we dus met $\alpha$/$\beta$ de symbolen voor het oneindig aantal vakjes met $\#$-symbolen begint.
\end{opm}

\begin{opm}
  De beginconfiguratie van een Turingmachine is altijd van de volgende vorm:
  \[ q_{s}\alpha \]
\end{opm}

\begin{opm}
  De eindconfiguratie van een Turingmachine is altijd van de volgende vorm:
  \[ \alpha q_{a} \beta \]
\end{opm}

\begin{opm}
  Tijdens de uitvoering van een TM zijn twee opeenvolgende configuraties verbonden door $\delta$ op \'e\'en van de volgende manieren, afhankelijk van of de turingmachine naar links gaat, naar rechts gaat, of terplaatse blijft na het schrijven.

  \begin{figure}[H]
    \centering
    \[
    \begin{array}{c|ccc}
      \delta & &\text{overgang}&\\
      \hline
      \delta(q,b) = (p,c,S) & \alpha q b \beta &\rightarrow& \alpha p a c \beta\\
      \delta(q,b) = (p,c,L) & \alpha a q b \beta &\rightarrow& \alpha p a c \beta\\ 
      \delta(q,b) = (p,c,R) & \alpha q b \beta &\rightarrow& \alpha c p \beta
    \end{array}
    \]
    \caption{Overgang van TM configuraties}
    \label{overgang-tm-configuraties}
  \end{figure}
\end{opm}

\begin{st}
  De berekeningskracht van prolog is gelijk aan die van een turingmachine.

  \begin{proof}
    We bewijzen elke richting appart, en geven slechts een schets van een bewijs.
    \begin{itemize}
    \item Een Turingmachine kan een Prologprogramma simuleren.\\
      We tonen dit niet direct aan, maar via een omweg.
      We tonen eerst aan dat Prolog ge\"implementeerd kan worden op een Intel machine.
      SWI Prolog is een voorbeeld hiervan.
      Vervolgens tonen we aan dat een Intel machine gesimuleerd kan worden met een registermachine.
      Tenslotte tonen we aan dat een registermachine gesimuleerd kan worden met een Turingmachine.
    \item Een Prologprogramma kan een Turingmachine simuleren.\\
      Het is heel eenvoudig in te zien dat een Turingmachine gesimuleerd kan worden met een Prologprogramma.
      Er zijn veel bestaande implementaties van zo'n programma.
      Er is zelfs een \verb|turing.pl| bestand binnen SWI Prolog.\cite{prolog-tm}
    \end{itemize}
  \end{proof}
\end{st}

\begin{de}
  Een Turingmachine kan een andere Turingmachine als subroutine oproepen.
\extra{Hoe formaliseren we dit?}
\end{de}

\begin{de}
  Een functie $f$ is Turing-berekenbaar als er een Turingmachine $T$ bestaat die, gegeven een argument $a$, het beeld van $a$ onder $f$ op de band kan zetten.
\question{Is dit wel juist?}
\end{de}

\begin{st}
  Het aantal Turing-machines is aftelbaar oneindig (op isomorfisme na).

  \begin{proof}
    Een Turing-machine wordt gekaracteriseerd door zijn overgangsfunctie $\delta$.
    \[ \delta:\ Q \times \Gamma \rightarrow Q \times \Gamma \times \{L,R,S\} \]
    In het voorschrift van $\delta$ is staan $Q,\Gamma$ en $\{L,R,S\}$. 
    Dit zijn alledrie eindige verzamelingen. 
    Voor een gegeven grootte van $\Gamma$ en $Q$ zijn er dus maar een eindig aantal Turingmachines.
    Beginnende bij $\Gamma = \{\#,a\}$ en $|Q|=1$ kunnen we dus alle Turringmachines opschrijven in volgorde volgens hun $(|Q|\cdot|\Gamma|)$-getal.
    Dit betekent dat we de Turingmachines kunnen nummeren.
    Er bestaat dus een bijectie tussen $\mathbb{N}$ en $TM$.
  \end{proof}
\end{st}

\extra{NDTMs?}

\TODO{taal van turingmachines is regulier}

\section{Encoderingen}
\label{sec:encoderingen}

\begin{de}
  Een encodering van een verzameling $A$ over een alfabet $\Sigma$ is een bijectieve afbeelding $e: A \rightarrow \Sigma^{*}$ die elk element afbeeldt op een string.
\end{de}

\begin{opm}
  Idealiter introduceert een encodering geen extra informatie.
\end{opm}

\begin{de}
  Twee encoderingen $e_{1}$ en $e_{2}$ zijn equivalent als de omzetting van de ene naar de andere codering Turing-berekenbaar is.
  \[ e_{1} \sim e_{2} \Leftrightarrow e_{2} \circ e_{1}^{-1} \text{ en } e_{1} \circ e_{2}^{-1} \text{ zijn Turing-berekenbaar.}\]
\end{de}

\begin{de}
  De encodering van een object $a$ noteren we als $<a>$.
\end{de}

\section{Universele Turingmachines}
\label{sec:univ-turingm}

\begin{de}
  Een \term{universele Turingmachine} is een Turingmachine die een willekeurige ge\"encodeerde Turingmachine kan simuleren.
\end{de}

\section{Het Halting probleem}
\label{sec:het-halting-probleem}

\begin{de}
  \label{de:a-tm}
  $A_{TM}$ is de taal van koppels $(M,s)$ waarbij $M$ een Turingmachine is die $s$ aanvaardt.
  \[ A_{TM} = \{ <M,s> \ |\ M \text{ is een Turingmachine en } s \in L_{M} \} \]
\end{de}

\begin{st}
  \label{st:a-tm-herk}
  $A_{TM}$ is herkenbaar.
  \begin{proof}
    De herkenner $H$ voor $A_{TM}$ laat bij input $<M,s>$ $M$ lopen op $s$.
    Als $M$ $s$ accepteert, dan accepteert $H$ $<M,s>$.
  \end{proof}
\end{st}

\begin{st}
  \label{gev:a-tm-niet-besl}
  $A_{TM}$ is niet beslisbaar.

  \begin{proof}
    Bewijs uit het ongerijmde.\\
    Stel dat er een beslisser $B$ bestaat voor $A_{TM}$.
    Dit betekent dat de TM $B$ de string $<M,s>$ accepteert als $M$ bij input $s$ zou stoppen in een accepterende toestand.
    $B$ zou bovendien de string $<M,s>$ verwerpen als $M$ bij input $s$ zou stoppen in een onaanvaardbare toestand, of niet zou stoppen.
    We construeren nu een machine (TM) $C$ die voor een contradictie moet zorgen.
    $C$ accepteert een string $<M>$ (met $M$ een $TM$) als $B$ $<M,<M>>$ niet accepteert.
    $C$ verwerpt een string $<M>$ als $B$ $<M,<M>>$ verwerpt.
    We beschouwen nu wat $C$ doet met de string $<C>$.
    Stel dat $C$ $<C>$ zou accepteren, dan betekent dat dat $B$ $<C<C>>$ accepteert (volgens de definitie van $B$), want $C$ is een machine die de string $<C>$ accepteert.
    Het betekent echter dat $C$ $<C>$ moet verwerpen(, volgens de definitie van $C$).
    \[ C \text{ accepteert } <C> \quad\Rightarrow\quad B \text{ accepteert } <C<C>> \quad\Rightarrow\quad C \text{ verwerpt } <C> \]
    Stel omgekeerd dat $C$ $<C>$ zou verwerpen, dan betekent dat dat $B$ $<C<C>>$ verwerpt (volgens de definitie van $B$), want $C$ is een machine die de string $<C>$ accepteert.
    Dat zou betekenen dat $C$ $<C<C>>$ moet accepteren(, volgens de definitie van $C$).
    \[ C \text{ verwerpt } <C> \quad\Rightarrow\quad B \text{ verwerpt } <C<C>> \quad\Rightarrow\quad C \text{ accepteert } <C> \]
    Bijgevolg kan $B$ niet bestaan.
    Contradictie.
  \end{proof}
\end{st}

\begin{gev}
  \label{gev:a-tm-niet-coherk}
  $A_{TM}$ is niet co-herkenbaar.
  \begin{proof}
    $A_{TM}$ is herkenbaar, maar niet beslisbaar, dus $A_{TM}$ is niet co-herkenbaar.\stref{st:herk-plus-coherk-is-besl}
  \end{proof}
\end{gev}


\begin{de}
  \label{de:h-tm}
  $H_{TM}$ is de taal van koppels $(M,s)$ waarbij $M$ een Turingmachine is die stopt bij input $s$.
  \[ H_{TM} = \{ <M,s> \ |\ M \text{ is een Turinmgmachine en } M \text{ stopt bij input } s \} \]
\end{de}

\begin{st}
  \label{st:h-tm-herk}
  $H_{TM}$ is herkenbaar.
  \begin{proof}
    De herkenner $H$ voor $H_{TM}$ laat bij input $<M,s>$ $M$ lopen op $s$.
    Als $M$ $s$ stopt, dan accepteert $H$ $<M,s>$.
  \end{proof}
\end{st}

\begin{st}
  \label{st:h-tm-niet-besl}
  $H_{TM}$ is niet beslisbaar.

  \begin{proof}
    Stel dat $H_{TM}$ beslisbaar is door een beslisser $H$.
    We construeren nu een beslisser $B$ voor $A_{TM}$ vanuit $H$.
    Bij input $<M,s>$ doet laat $B$ eerst $H$ lopen op $<M,s>$.
    Als $H$ accepteert(, dus $M$ stopt bij input $s$) laat $B$ $M$ lopen op $s$ en geeft als resultaat het resultaat van $M$.
    Als $H$ niet accepteert(, dus $M$ stopt niet bij input $s$) verwerpt $B$ ook.
    Vermits er geen beslisser bestaat voor $A_{TM}$, kan $H$ niet bestaan en is $H_{TM}$ dus ook niet beslisbaar.
  \end{proof}
\end{st}

\begin{gev}
  \label{gev:h-tm-niet-coherk}
  $H_{TM}$ is niet co-herkenbaar.
  \begin{proof}
    $H_{TM}$ is herkenbaar, maar niet beslisbaar, dus $H_{TM}$ is niet co-herkenbaar.\stref{st:herk-plus-coherk-is-besl}
  \end{proof}
\end{gev}

\section{De enumeratormachine}
\label{sec:de-enumeratormachine}

\begin{de}
  Een \term{enumeratormachine} is een is een $7$-tal $(Q,\Sigma,\Gamma, \delta, q_{s}, q_{a}, q_{r})$, gelijkaardig aan een Turingmachine.
  De overgangsfunctie heeft voor een enumeratormachine een andere signatuur:
  \[ \delta:\ Q \times \Gamma \rightarrow Q \times \Gamma \times \Gamma_{\epsilon}\times \{L,R,S\} \]
  Een enumeratormachine heeft bovendien een enumeratortoestand $q_{e}$, een outputband (naast de inputband) en een outputmarker.
  Wanneer de enumeratormachine een stap afrondt, schrijft hij ook nog een symbool weg naar de outputband en gaat daar ook steeds naar rechts. Wanneer de machine in toestand $q_{e}$ belandt, schrijft hij de outputmarker naar de outputband, en gaat terug over in de begintoestand $q_{s}$.
\end{de}

\begin{de}
  De taal bepaald door een enumeratormachine is de verzameling van strings die volledig op de outputband belanden, gescheiden door de outputmarker.
\end{de}

\begin{de}
  We noemen een taal \term{enumereerbaar} als er een enumeratormachine bestaat die die taal bepaalt.
\end{de}

\begin{st}
  \label{st:enumer-is-herk}
  De taal bepaald door een enumerator $E$ is herkenbaar.
  \begin{proof}
    We beschrijven een herkenner $H$ voor de taal $L$ bepaald door een enumerator $E$.
    Gegeven een string $s$ als input doet $H$ het volgende.
    $H$ laat $E$ lopen tot $E$ een string $s'$ heeft afgemaakt.
    Vervolgens kijkt $H$ of $s$ en $s'$ gelijk zijn.
    Zo ja, accepteert $H$ $s$.
  \end{proof}
\end{st}

\begin{st}
  \label{st:herk-is-enumer}
  Elke herkenbare is enumereerbaar.
  \begin{proof}
    Zij $M$ een $TM$ die een taal $L$ bepaalt.
    $L$ is dus herkenbaar.
    We construeren nu de enumerator $E$ die $L$ enumereert.
    Eerst construeren we een $TM$ $gen$ die, gegeven een input $n$, de eerste $n$ strings van $\Sigma^{*}$ op de band zet.
    Vervolgens construeren we een $TM$ $M_{n}$ die, gegeven een input $n$, de eerste $n$ stappen van $M$ uitvoert.
    Tenslotte construeren we de enumerator $E$ die de opeenvolgende natuurlijke getallen genereert, en na elk getal eerst $gen$ uitvoert, dan $M_{n}$ uitvoert, en elke string op de band zet die $M_{n}$ accepteert.
  \end{proof}
\end{st}

\section{Beslisbare talen}
\label{sec:beslisbare-talen}

\subsection{In verband met reguliere talen}
\label{sec:verb-met-regul}

\begin{de}
  \label{de:a-dfa}
  $A_{DFA}$ is de taal van koppels $(D,s)$ waarbij $D$ een DFA is die $s$ aanvaardt.
  \[ A_{DFA} = \{ <D,s> \ |\ D \text{ is een DFA en } s \in L_{D} \} \]
\end{de}

\begin{st}
  \label{st:a-dfa-besl}
  $A_{DFA}$ is beslisbaar.

  \begin{proof}
    Een beslisser $B$ voor $A_{DFA}$ krijgt als input $<D,s>$ met $D$ een $DFA$.
    De beslisser simuleert $D$, en accepteert $s$ als en slechts als $D$ $s$ accepteert.
\clarify{waarom kan een TM een DFA simuleren, hoe?}
  \end{proof}
\end{st}

\begin{de}
  \label{de:a-re}
  $A_{RE}$ is de taal van koppels $(R,s)$ waarbij $R$ een reguliere expressie is die $s$ genereert.
  \[ A_{RE} = \{ <R,s> \ |\ R \text{ is een reguliere expressie en } s \in L_{R} \} \]
\end{de}

\begin{st}
  \label{st:a-re-besl}
  $A_{RE}$ is beslisbaar.

  \begin{proof}
    Een beslisser $B$ voor $A_{RE}$ krijgt als input een reguliere expressie $R$ en een string $s$ als $<R,s>$.
    De beslisser construeert dan een DFA voor $R$\gevref{gev:reguliere-taal-DFA} en roept daarna een beslisser voor $A_{DFA}$ op.\stref{st:a-dfa-besl}
  \end{proof}
\end{st}

\begin{de}
  \label{de:a-nfa}
  $A_{NFA}$ is de taal van koppels $(N,s)$ waarbij $N$ een NFA is die $s$ aanvaardt.
  \[ A_{NFA} = \{ <N,s> \ |\ N \text{ is een NFA en } s \in L_{N} \} \]
\end{de}

\begin{st}
  \label{st-a-nfa-besl}
  $A_{NFA}$ is beslisbaar.

  \begin{proof}
    Een beslisser $B$ voor $A_{NFA}$ krijgt als input $<N,s>$.
    $B$ zet $N$ eerst om naar een DFA\stref{st:nfa-naar-dfa} en roept daarna een beslisser voor $A_{DFA}$ op.\stref{st:a-dfa-besl}
  \end{proof}
\end{st}

\question{welk verschil p 100?}

\begin{de}
  \label{de:e-dfa}
  $E_{DFA}$ is de taal van alle machines $D$ die de lege taal bepalen.
  \[ E_{DFA} = \{ <D,s>\ |\ D \text{ is een DFA en } L_{D} = \emptyset \} \]
\end{de}

\begin{st}
  \label{st:e-dfa-besl}
  $E_{DFA}$ is beslisbaar.

  \begin{proof}
    We construeren een beslisser $B$ voor $E_{DFA}$.
    De beslisser krijg (de encodering van) een DFA $D$ als invoer.
    De beslisser vormt $D$ om tot een minimale DFA $D'$.\alref{al:dfa-minimalisatie}
    Als $D$ (en dus ook $D'$) de lege taal bepaalt, is $D'$ isomorf met de $NFA_{\phi}$ \figref{fig:nfa_phi}.
    Dat is eenvoudig beslisbaar.
\waarom
  \end{proof}
\end{st}

\begin{de}
  \label{de:eq-dfa}
  $EQ_{DFA}$ is de taal van alle koppels DFA's die dezelfde taal bepalen.
  \[ EQ_{DFA} = \{ <D_{1},D_{2}> \ |\ D_{1},D_{2} \text{ zijn DFA's en } L_{D_{1}} = L_{D_{2}} \} \]  
\end{de}

\begin{st}
  \label{st:eq-dfa-besl}
  $EQ_{DFA}$ is beslisbaar.

  \begin{proof}
    We construeren een beslisser $B$ voor $EQ_{DFA}$ als volgt:
    $B$ krijgt als input $<D_{1},D_{2}>$ en construeert vervolgens de DFA $D$ die het symmetrisch verschil bepaalt van $L_{D_{1}}$ en $L_{D_{2}}$.
    Vervolgens beslist $B$ of $D$ de lege taal bepaalt.\stref{st:e-dfa-besl}
\clarify{waarom kan dit zomaar? verwijs naar stuk over die constructie bij dfa's}
  \end{proof}
\end{st}

\begin{de}
  Een formalisme is \term{Turing compleet} als er de berekeningen van een Turingmachine mee nagebootst kan worden.
\extra{zet dit op een betere plaats?}
\end{de}
\subsection{In verband met contextvrije talen}
\label{sec:verb-met-cont}

\begin{de}
  \label{de:a-cfg}
  $A_{CFG}$ is de taal van koppels $(C,s)$ waarbij $C$ een contextvrije grammatica is die $s$ genereert.
  \[ A_{CFG} = \{ <G,s> \ |\ G \text{ is een CFG en } s \in L_{C} \} \]
\end{de}

\begin{st}
  \label{st:a-cfg-besl}
  $A_{CFG}$ is beslisbaar.

  \begin{proof}
    We construeren een beslisser $B$ voor $A_{CFG}$.
    $B$ krijgt als input een string $<G,s>$ en converteert eerst $G$ naar Chomsky Normaal Vorm.
    Vervolgens genereert $G$ alle mogelijke strings afleidingslengte $2|s| - 1$.
    Dat zijn er eindig veel.
    Als $s$ erbij zit, genereert $G$ $s$.\stref{st:chomsky-normaalvorm-afleidingslengte}
    $B$ accepteert $<G,s>$ dan, anders niet.
  \end{proof}
\end{st}

\begin{de}
  \label{de:e-cfg}
  $E_{CFG}$ is de taal van CFG's $C$ die de lege taal bepalen.
  \[ E_{CFG} = \{ <C,s>\ |\ D \text{ is een CFG en } L_{C} = \emptyset \} \]
\end{de}

\begin{st}
  \label{st:e-cfg-besl}
  $E_{CFG}$ is beslisbaar.

  \begin{proof}
    We construeren een beslisser $B$ voor $E_{CFG}$.
    $B$ krijgt als input een string $<G,s>$ en gaat als volgt te werk:
    $B$ verwijdert algoritmisch regels uit $G$ zodat de resulterende CFG equivalent is, maar $B$ makkelijker een beslissing laat maken.
    Voor alle regels $A \rightarrow \alpha$ waarbij $\alpha$ enkel bestaat uit eindsymbolen verwijdert $B$ alle regels waarin $A$ aan de linkerkant voorkomt en vervangt $B$ $A$ door $alpha$ in alle regels waar $A$ aan de rechterkant voorkomt.
    Als het startsymbool verwijderd wordt verwerppt $B$ $<G,s>$, want dan kon uit $S$ een string afgeleid worden.
    Wanneer er geen regels meer zijn van de beschreven vorm accepteert $B$ $<G,s>$.
\clarify{dit kan mooier, denk ik?}
  \end{proof}
\end{st}

\begin{de}
  \label{de:es-cfg}
  $ES_{CFG}$ is de taal van alle CFG's die de lege string aanvaarden.
  \[ ES_{CFG} = \{ <C> \ |\ C \text{ is een CFG en } \epsilon \in L_{C}\} \]
\end{de}

\begin{st}
  \label{st:es-cfg-besl}
  $ES_{CFG}$ is beslisbaar.

  \begin{proof}
    We construeren een beslisser $B$ voor $ES_{CFG}$.
    $B$ krijgt als input een string $<G,s>$ en gaat als volgt te werk:
    $B$ transformeert $G$ naar zijn Chomsky Normaal Vorm en kijkt na of er een regel van de vorm $S \rightarrow \epsilon$ overblijft.
    Zo ja accepteert $B$, anders verwerpt $B$.
  \end{proof}

  \begin{proof}
    Een beslisser voor $ES_{CFG}$ roept een beslisser voor $A_{CFG}$ op met als invoer de gegeven CFG en de lege string.\stref{st:a-cfg-besl}
  \end{proof}
\end{st}

\begin{st}
  Een contextvrije taal $L$ is beslisbaar.

\extra{bewijs}
\end{st}

\begin{st}
  $EQ_{CFG}$ is niet herkenbaar.
\TODO{bewijs intuitief p 103}
\end{st}

\begin{st}
  $EQ_{CFG}$ is co-herkenbaar.
\extra{bewijs}
\end{st}

\begin{gev}
  $EQ_{CFG}$ is niet beslisbaar.
\TODO{bewijs}
\end{gev}

\section{Niet-beslisbare talen}
\label{sec:niet-besl-talen}

\begin{de}
  \label{de:e-tm}
  $E_{TM}$ is de taal van alle Turingmachines die geen enkele string aanvaardt.
  \[ E_{TM} = \{ <M,s>\ |\ M \text{ is een Turingmachine en } L_{M} = \phi \} \]
\end{de}

\begin{st}
  $E_{TM}$ is niet beslisbaar.
\TODO{bewijs p 104}
\end{st}

\begin{de}
  \label{de:regular-tm}
  $REGULAR_{TM}$ is de taal van alle Turingmachines die een reguliere taal bepaalt.
\end{de}

\begin{st}
  $REGULAR_{TM}$ is niet beslisbaar.
\TODO{bewijs p 105}
\end{st}

\begin{de}
  \label{de:eq-tm}
  $EQ_{TM}$ is de taal van alle koppels Turingmachines die dezelfde taal herkennen/beslissen.
\clarify{herkennen of beslissen?}
\TODO{bewijs p 105}
\end{de}

\begin{de}
  Een \term{lineair begrensde automaat} (LBA) is een Turingmachine die niet leest of schrijft buiten een deel van de geheugenstrook dat een constante factor groter is dan de invoerstring.
\end{de}

\begin{st}
  De taal die alle Turingmachines bevat die ook een LBA zijn is niet beslisbaar.
\extra{bewijs p 106}
\end{st}

\begin{de}
  \label{de:a-lba}
  $A_{LBA}$ is de taal van alle koppels $(L,s)$ waarbij $L$ een LBA is die $s$ aanvaardt.
  \[ A_{LBA} = \{ <L,s> \ |\ L \text{ is een LBA en } s \in L_{L}\} \]
\end{de}

\begin{st}
  $A_{LBA}$ is beslisbaar.
\TODO{bewijs p 106}
\end{st}

\begin{de}
  \label{de:e-lba}
  $E_{LBA}$ is de taal van alle LBA's die geen enkele string aanvaarden.
  \[ E_{LBA} = \{ <L> \ |\ L \text{ is een LBA en } L_{L} = \emptyset \} \]
\end{de}

\begin{st}
  $E_{LBA}$ is niet herkenbaar.
\TODO{bewijs p 107}
\end{st}

\begin{st}
  $E_{LBA}$ is co-herkenbaar.
\extra{bewijs}
\end{st}

\begin{gev}
  $E_{LBA}$ is beslisbaar.
\TODO{bewijs}
\end{gev}

\extra{p 108 acceptance, halting en leegheid van LBA,PDA en TM}

\begin{st}
  $ALL_{CFG}$ is niet herkenbaar.
  \begin{proof}
    Het bewijs wordt niet gezijn.
    \extra{verwijzing naar een bewijs}
  \end{proof}
\end{st}

\begin{st}
  $ALL_{CFG}$ is co-herkenbaar.
\extra{bewijs}
\end{st}

\begin{gev}
  $ALL_{CFG}$ is niet beslisbaar.
\TODO{bewijs}
\end{gev}

\extra{$ALL_{RegExp}$ is beslisbaar: bewijs}

\section{Weetjes}
\label{sec:weetjes}

\begin{st}
  \[ RegLan \subsetneq DCFL \subsetneq CFL \subsetneq Besl \subsetneq Herk \subsetneq \mathcal{P}(\Sigma^{*}) \]
  \extra{bewijs}
\end{st}

\begin{st}
  $RegLan$ is gesloten onder de unie, doorsnede, complement.
\extra{bewijs}
\end{st}

\begin{st}
  $DCFL$ is gesloten onder complement, maar $CFL$ niet. 
\extra{bewijs}
\end{st}

\begin{st}
  $Besl$ is gesloten onder de unie en het complement.
\extra{bewijs}
\end{st}

\begin{st}
  $Herk$ is gesloten onder de unie.
\extra{bewijs}
\end{st}

\begin{st}
  $RegLan$, $CFL$ en $Herk$ zijn gesloten onder de omkering.
\extra{bewijs}
\end{st}

\begin{st}
  $DCFL$ is niet gesloten onder de omkering.
\extra{bewijs zie p 109 voor vb}
\end{st}

\begin{de}
  Een verzameling $V$ is \term{effectief aftelbaar} of \term{opsombaar} als en een TM bestaat die alle elementen uit $v$ (eventueel geencodeerd) \'e\'en voor \'e\'en genereert.
\end{de}

\section{Algemene problemen}
\label{sec:algemene-problemen}

\begin{de}
  Acceptatie\\
  Zij $\phi$ een verzameling machines, dan is $A_{\phi}$ de taal van alle koppels $(M,s)$ waarbij $M\in \phi$ een machine is die $s$ aanvaardt.
  \[ A_{\phi} = \{ <M,s> \ |\ M\in \phi \wedge s \in L_{M} \} \]
\end{de}

\begin{de}
  Stopt\\
  Zij $\phi$ een verzameling machines, dan is $H_{\phi}$ de taal van alle koppels $(M,s)$ waarbij $M\in \phi$ een machine is die stopt bij input $s$.
  \[ H_{\phi} = \{ <M,s> \ |\ M \in \phi \wedge M \text{ stopt bij input } s \} \]
\end{de}

\begin{de}
  Leegheid\\
  Zij $\phi$ een verzameling machines, dan is $E_{\phi}$ de taal van alle machines $M$ die de lege taal bepalen.
  \[ E_{\phi} = \{ <M,s>\ |\ M \in \phi \wedge L_{M} = \emptyset \} \]
\end{de}

\begin{de}
  Gelijkheid\\
  Zij $\phi$ een verzameling machines, dan is $EQ_{\phi}$ de taal van alle koppels $M_{1},M_{2}$ waarbij $M_{1}$ en $M_{2}$ dezelfde taal bepalen.
  \[ EQ_{\phi} = \{ <M_{1},M_{2}> \ |\ M_{1},M_{2} \in \phi \wedge L_{M_{1}} = L_{M_{2}} \} \]
\end{de}

\begin{de}
  Lege string\\
  Zij $\phi$ een verzameling machines, dan is $ES_{\phi}$ de taal van alle machines $M$ die de lege string aanvaarden.
  \[ ES_{\phi} = \{ <M> \ |\ M\in \phi \wedge \epsilon \in L_{M}\} \]
\end{de}

\begin{de}
  Regulier\\
  Zij $\phi$ een verzameling machines, dan is $REGULAR_{\phi}$ de taal van alle machines $M$ die een reguliere taal bepalen.
\end{de}

\begin{de}
  Zij $\phi$ een verzameling machines, dan is $ALL_{\phi}$ de taal van alle machines $M$ die alle strings aanvaarden.
\end{de}

\begin{figure}[!p]  
  \centering
  \begin{tabular}[H]{cc}
    \pvak{\footnotesize{Herkenbaar}}{\footnotesize{Niet Co-herkenbaar}}{H} & \pvak{\footnotesize{Niet Herkenbaar}}{\footnotesize{Co-herkenbaar}}{C}
  \end{tabular}
  \begin{tabular}[H]{cccc}
    \pvak{\ref{de:a-re}}{$A_{RE}$}{B} & \pvak{\ref{de:a-cfg}}{$A_{CFG}$}{B} & \pvak{\ref{de:a-csg}}{$A_{CSG}$}{B} & \pvak{\ref{de:a-tm}}{$A_{TM}$}{H}\\
    \pvak{\ref{de:h-re}}{$H_{RE}$}{B} & \pvak{\ref{de:h-cfg}}{$H_{CFG}$}{B} & \pvak{\ref{de:h-csg}}{$H_{CSG}$}{B} & \pvak{\ref{de:h-tm}}{$H_{TM}$}{H}\\
    \pvak{\ref{de:e-re}}{$E_{RE}$}{B} & \pvak{\ref{de:e-cfg}}{$E_{CFG}$}{B} & \pvak{\ref{de:e-csg}}{$E_{CSG}$}{H} & \pvak{\ref{de:e-tm}}{$E_{TM}$}{C}\\
    \pvak{\ref{de:eq-re}}{$EQ_{RE}$}{B} & \pvak{\ref{de:eq-cfg}}{$EQ_{CFG}$}{H} & \pvak{\ref{de:eq-csg}}{$EQ_{CSG}$}{H} & \pvak{\ref{de:eq-tm}}{$EQ_{TM}$}{N}\\
    \pvak{\ref{de:es-re}}{$ES_{RE}$}{B} & \pvak{\ref{de:es-cfg}}{$ES_{CFG}$}{B} & \pvak{\ref{de:es-csg}}{$ES_{CSG}$}{B} & \pvak{\ref{de:es-tm}}{$ES_{TM}$}{H}\\
    \pvak{\ref{de:regular-re}}{$REGULAR_{RE}$}{B} & \pvak{\ref{de:regular-cfg}}{$REGULAR_{CFG}$}{N} & \pvak{\ref{de:regular-csg}}{$REGULAR_{CSG}$}{N} & \pvak{\ref{de:regular-tm}}{$REGULAR_{TM}$}{N}\\
    \pvak{\ref{de:all-re}}{$ALL_{RE}$}{B} & \pvak{\ref{de:all-cfg}}{$ALL_{CFG}$}{H} & \pvak{\ref{de:all-csg}}{$ALL_{CSG}$}{H} & \pvak{\ref{de:all-tm}}{$ALL_{TM}$}{N}\\
  \end{tabular}
  \caption{Algemene problemen}
  \label{fig:algemene-problemen}
\end{figure}


\section{De stelling van Rice}
\label{sec:de-stelling-van}

\begin{de}
  Een \term{eigenschap} $P$ van een $\phi$-machine is een predicaat dat de verzameling van $\phi$-machines in twee verdeelt: $Pos_{P}$, de verzameling van $\phi$-machines die $P$ bezitten en $Neg_{P}$, de verzameling van $\phi$-machines die $P$ niet bezitten.
  \[ Pos_{P} = \{ \phi \ |\ P(\phi) \} \quad\text{ en }\quad Neg_{P} = \{ \phi \ |\ \neg P(\phi) \} \]
\extra{mooiere beschrijving van $\phi$?}
\end{de}

\begin{de}
  Een \term{niet-triviale eigenschap} is een eigenschap waarvoor zowel $Pos_{P}$ als $Neg_{P}$ niet leeg is.
\end{de}

\begin{de}
  Een \term{taal-invariante eigenschap} van een machine $phi$ is een eigenschap die enkel afhankelijk is van de taal die $\phi$ bepaalt.
  \[ \forall M_{1},M_{2}:\ L_{M_{1}} = L_{M_{2}} \Rightarrow (P(M_{1}) \Leftrightarrow P(M_{2})) \]
\end{de}

\begin{st}
  \label{st:eerste-stelling-van-rice}
  Eerste \term{stelling van Rice}\\
  Voor elke niet-triviale, taal-invariante eigenschap $P$ van Turingmachines is noch $Pos_{P}$ noch $Neg_{P}$ beslisbaar.

\TODO{bewijs p 112}
\end{st}

\extra{tweede stelling van rice}
\extra{voor welke vorige stellingen kunnen we de stelling van rice gebruiken?}

\section{Post Correspondence}
\label{sec:post-correspondence}

\begin{de}
  Een \term{(domino)steen} over een alfabet $\Sigma$ is een koppel strings $(a,b)$ over $\Sigma$.
  Het eerste deel van het koppel noemen we de bovenkant en het tweede deel de onderkant.
\end{de}

\begin{de}
  \label{post:correspondence}
  Een \term{Post correspondence} spel.\\
  Gegeven een eindige verzameling stenen $S$ is de vraag:
  \begin{center}
    Bestaat er een opeenvolging van stenen uit $S$, zodat de string in de bovenkanten samen gelijk is aan de string in de onderkanten samen.
  \end{center}
\end{de}

\begin{st}
  \label{st:pc-is-turing-compleet}
  Het Post correspondence spel is Turing-compleet.
\extra{bewijs, bekijk vb in cursus p 114}
\end{st}

\begin{gev}
  Het Post correspondence spel is onbeslisbaar voor verzamelingen stenen over een alfabet groter dan $1$ symbool.
\extra{bewijs}
\end{gev}

\extra{2-tag systems}

\section{Reductie}
\label{sec:reductie}

\begin{de}
  Een functie $f$ is \term{Turing-berekenbaar} als er een Turingmachine bestaat die voor elke $s$ in het domein van $f$, $f(s)$ op de band zet.
\end{de}

\begin{de}
  We korten Turing-berekenbaar vaak af tot berekenbaar.
\end{de}

\begin{de}
  We zeggen dat een taal $L_1$ (over $\Sigma_1$) gereduceert kan worden naar $L_2$ (over $\Sigma_2$) als er een afbeelding $f$ als volgt:
  \[  f:\ \Sigma_1\rightarrow \Sigma_1  \]
  \begin{itemize}
    \item $f(L_1) \subseteq L_2$
    \item $f(\overline{L_1}) \subseteq \overline{L_2}$
    \item $f$ is Turing-berekenbaar
  \end{itemize}
  \[ L_1\le_m L_2 \]
\end{de}

\begin{st}
  Zij $L_1$ en $L_2$ talen over, respectievelijk, $\Sigma_1$ en $\Sigma_2$.
  \[ L_1\le_m L_2 \Rightarrow (L_1 \text{ is beslisbaar } \Rightarrow L_2 \text{ is beslisbaar }) \]
\extra{bewijs}
\end{st}


\begin{st}
  Zij $L_1$ en $L_2$ talen over, respectievelijk, $\Sigma_1$ en $\Sigma_2$.
  \[ L_1\le_m L_2 \Rightarrow (L_1 \text{ is herkenbaar } \Rightarrow L_2 \text{ is herkenbaar }) \]
\extra{bewijs}
\end{st}


\begin{st}
  $EQ_{TM}$ is niet beslisbaar.

  \begin{proof}
    We weten dat $E_{TM}$ niet beslisbaar is.
    We reduceren $E_{TM}$ naar $EQ_{TM}$ met de functie $f$:
    \[
    <M> \mapsto <M,M_{\phi}>
    \]
    $f$ is duidelijk Turing-berekenbaar.
\waarom
  \end{proof}
\end{st}

\begin{st}
  Zij $A$ en $B$ twee talen.
  \[ A \le_m B \Rightarrow \overline{a} \le_m \overline{b} \]
\end{st}

\begin{st}
  $EQ_{TM}$ is niet herkenbaar en ook niet co-herkenbaar.

\TODO{bewijs p 119}
\end{st}

\section{Orakelmachines}
\label{sec:orakelmachines}

\begin{de}
  Een orakel voor een taal $L$ is een machine die in een eindige hoeveelheid tijd kan beslissen of een string tot $L$ behoort.
\end{de}

\begin{de}
  Een orakelmachine $O^{L}$ is een machine die als subroutine een orakel voor de taal $L$ kan aanroepen.
\end{de}

\begin{st}
  Er bestaat een orakelmachine $O^{A_{TM}}$ die $E_{TM}$ beslist.
\TODO{bewijs p 120}
\end{st}

\begin{de}
  Een taal $A$ is \term{Turingreduceerbaar} naar een taal $B$ als $A$ beslisbaar is ten opzichte van $B$.
  Dit betekent dat er een orakelmachine $O^{B}$ bestaat die $A$ beslist.
  \[ A \le_{T} B \]
\end{de}

\begin{st}
  Als $A$ Turingreduceerbaar is ten opzichte van $B$ en $B$ beslisbaar, dan is $A$ beslisbaar.
\extra{bewijs}
\end{st}

\begin{st}
  Als $A$ reduceerbaar is naar $B$, dan is $A$ ook Turingreduceerbaar naar $B$.
\end{st}

\begin{gev}
  $\le_{m}$ is dus fijner dan $\le_{r}$.
\extra{bewijs}
\end{gev}

\section{Recursieve functies}
\label{sec:recursieve-functies}

\subsection{Primitief recursieve functies}
\label{sec:prim-recurs-funct}

\subsubsection{Basisfuncties}
\label{sec:basisfuncties}

\begin{de}
  De \term{nulfunctie} is een functie die elk natuurlijk getal afbeeldt op nul.
  \[ nul:\ \mathbb{N} \rightarrow \mathbb{N}:\ x \mapsto 0 \]
\end{de}

\begin{de}
  De \term{successorfunctie} is een functie die elk natuurlijk getal afbeeldt op het volgende natuurlijk getal.
  \[ succ: \mathbb{N} \rightarrow \mathbb{N}:\ x \mapsto x+1 \]
\end{de}

\begin{de}
  De $i$-de \term{projectie} van een $n$-tal is een functie die een $n$-tal afbeeldt op het $i$-de element uit dat $n$-tal.
  \[ p_{i}^{n}: \mathbb{N}^{n} \rightarrow \mathbb{N}:\ (x_{1},x_{2}, \dotsc, x_{n}) \mapsto x_{i} \]
\end{de}

\subsubsection{Compositie}
\label{sec:compositie}

\begin{de}
  De \term{compositiefunctie} $Cn$ is een functie die een functie $f$ 'evalueert', gegeven zijn argumenten.
  Gegeven de volgende elementen:
  \begin{itemize}
  \item 
    $m$ functies $g_{i}$: $g_{1},g_{2},\dotsc,g_{m}$ met elk $k$ argumenten.
    \[ g_{i}:\ \mathbb{N}^{k} \rightarrow \mathbb{N} \]
  \item 
    $f$, een functie met $m$ argumenten.
    \[ f:\ \mathbb{N}^{m} \rightarrow \mathbb{N} \]
  \end{itemize}
  We kunnen dan een $h$ construeren als volgt:\footnote{$\bar{x} = (x_{1},x_{2},\dotsc,x_{k})$}
  \[ h:\ \mathbb{N}^{k} \rightarrow \mathbb{N}:\ \bar{x} \mapsto f(g_{1}(\bar{x}),g_{2}(\bar{x}),\dotsc,g_{m}(\bar{x})) \]
  We noteren $h$ als volgt:
  \[ h = Cn(f,g_{1},\dotsc,g_{m}) \]
\end{de}

\subsubsection{Primitieve recursie}
\label{sec:primitieve-recursie}

\begin{de}
  De \term{primitieve recursiefunctie} is een functie die toelaat om functies recursief samen te stellen.
  Gegeven de volgende elementen...
  \begin{itemize}
  \item Een functie $f$ die een $k$-tal natuurlijke getallen afbeeldt op een natuurlijk getal.
    \[ f: \mathbb{N}^{k} \rightarrow \mathbb{N} \]
  \item Een functie $g$ die een $k+2$-tal natuurlijke getallen afbeeldt op een natuurlijk getal.
    \[ g: \mathbb{N}^{k+2} \rightarrow \mathbb{N} \]
  \end{itemize}
  ... kunnen we een functie $h$ construeren die recursief te werk gaat.
  \[ 
  h:\ \mathbb{N}^{k+1} \rightarrow \mathbb{N}:\ 
  \left\{
    \begin{array}{ll}
      h(\bar{x},0) &= f(\bar{x})\\
      h(\bar{x},y+1) &= g(\bar{x}, y, h(\bar{x},y))\\
    \end{array}
  \right.
  \]
  We noteren $h$ tenslotte als volgt:
  \[ h = Pr(f,g) \]
\end{de}

\begin{de}
  Een \term{primitief recursieve functie} is een functie die je kan maken door functies samen te stellen met behulp van de compositie en primitieve recursie.
\end{de}

\subsection{Een niet-primitief recursieve functie}
\label{sec:een-niet-primitief}

\begin{de}
  De \term{Ackerman functie} is als volgt gedefinieerd:
  \[ 
  Ack:\ \mathbb{N}^{2} \rightarrow \mathbb{N}:\ 
  \left\{
    \begin{array}{llll}
      Ack(0,y)   &= y+1\\
      Ack(x,0)   &= Ack(x-1,1)\\
      Ack(x,y)   &= Ack(x-1,Ack(x,y-1))\\
    \end{array}
  \right.
  \]
\end{de}

\begin{st}
  De Ackerman functie is niet primitief recursief.
\extra{bewijs}
\end{st}

\begin{de}
  De \term{onbegrensde minimisatie} functie is een proces dat voor een gegeven functie de minimale nulpunten vindt.\\
  Gegeven een functie $f: \mathbb{N}^{k+1} \rightarrow \mathbb{N}$ construeren we de onbegrensde minimisatie als volgt:
  \[
  g:\ \mathbb{N}^{k} \rightarrow \mathbb{N}:\ g(\bar{x}) = y
  \Leftrightarrow
  \left\{
    \begin{array}{rl}
      f(\bar{x},y) &= 0\\
      \forall z \in \mathbb{N}: z < y &\Rightarrow  f(\bar{x},z) \neq 0
    \end{array}
  \right.
  \]
  We noteren $g$ als volgt:
  \[ g = Mn(f) \]
\end{de}

\begin{opm}
  Een eenvoudigere manier om je $Mn$ voor te stellen ziet er als volgt uit:
  \begin{verbatim}
    y = 0;
    while (f(x,y) != 0)
      y++;
    return y;
  \end{verbatim}
\end{opm}

\begin{de}
  Een \term{recursieve functie} is een functie die je verkrijgt door het samenstellen van de basisfuncties, de primitieve recursie, de samenstelling en de onbegrensde minimisatie.
\end{de}

\begin{st}
  Elke recursieve functie is Turing-berekenbaar en omgekeerd.
\extra{bewijs}
\end{st}


\section{De busy beaver functie}
\label{sec:de-busy-beaver}

\begin{de}
  Een \term{busy beaver} Turingmachine is de Turingmachine (over het alfabet $\{0,1\}$) die bij een lege input het meeste enen op de band zet van alle Turingmachines met $n$ toestanden en toch stopt.
\end{de}

\begin{de}
  Het aantal enen op de band gezet door een busy beaver Turingmachine met $n$ toestanden noteren we als $\Sigma(n)$.
  \[ \Sigma:\ \mathbb{N} \rightarrow \mathbb{N}  \]
\end{de}

\begin{st}
  $\Sigma$ is niet Turingberekenbaar.
\extra{bewijs}
\end{st}

\begin{st}
  $\Sigma$ is de snelst stijgende functie.
\extra{bewijs}
\end{st}

\end{document}
